# 什么是设计模式?

> 通俗来讲,设计模式就是针对某一种特殊场景而给出的标准解决方案，它是前辈们的经验性总结，
也是实现软件工程化的基础，良好的设计模式应用 可以是我们的软件变得更加健壮可维护。


# 设计模式按照类型划分可以分为三大类:

* 创建型设计模式
> 如同它的名字那样，它是用来解耦对象的实例化过程。
* 结构型设计模式
> 将类和对象按照一定规则组合成一个更加强大的结构体。
* 行为型设计模式
> 定义类和对象的交互行为。

# 创建型设计模式
 * 单例模式(某个类只有一个实例,提供一个全局的访问点)
 * 建造者模式(封装一个复杂对象的构建过程,按照步骤构建对象)
 * 原型模式(通过复制现有的实例来创建新的实例)
 * 简单工厂模式(一个工厂类根据传入的参数创建创建哪一种产品的实例)
 * 工厂模式(定义一个创建对象的接口,让子类决定实例化哪个类)
 * 抽象工厂模式(创建相关依赖对象的家族,而无需指定具体类)
 # 结构型设计模式
 * 适配器模式(将一个类的方法和接口转换成客户希望的另外一个接口)
 * 组合模式(将对象组合成树形结构以表示整体和部分的层次结构)
 * 装饰模式(动态的给对象添加新的功能)
 * 外观模式(对外提供一个统一的方法,用来访问子系统中的一群接口)
 * 桥接模式(将抽象部分和实现部分相互分离,它们都可以独立变化)
 * 享元模式(通过共享技术来有效的支持大量细粒度的对象)
 * 代理模式(为其他对象提供一个代理以便控制这个对象的访问)
 # 行为型设计模式
 * 模板模式(定义一个算法结构,而将一些步骤延迟到子类实现)
 * 解释器模式(给定一个语音,定义它的文法的一种表示,并定义个解释器)
 * 策略模式(定义一系列算法,把他们封装起来,并且使它们可以相互转换)
 * 状态模式(允许一个对象在其内部对象状态改变时改变它们的行为)
 * 观察者模式(观察一对多的依赖关系)
 * 备忘录模式(在不破坏封装的情况下,保持对象的内部状态)
 * 中介者模式(用一个中介对象来封装一系列对象的交互)
 * 命令模式(将命令请求封装为一个对象,可以将不同的请求进行参数化)
 * 访问者模式(在不改变数据结构的前提下,增加作用于一组对象元素的新功能)
 * 责任链模式(将请求的发送者和接受者解耦,使得多个对象都有处理这个请求的机会)
 * 迭代器模式(一种遍历访问聚合对象各个元素的方法,不暴露给对象的内部结构)


